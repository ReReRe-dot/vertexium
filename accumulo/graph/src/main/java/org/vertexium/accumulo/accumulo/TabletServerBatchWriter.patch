--- accumulo/graph/src/main/java/org/vertexium/accumulo/accumulo/TabletServerBatchWriter.java	2020-03-23 12:39:13.962016697 -0400
+++ accumulo/graph/src/main/java/org/vertexium/accumulo/accumulo/VertexiumTabletServerBatchWriter.java	2020-03-23 12:41:09.810921876 -0400
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.accumulo.core.client.impl;
+package org.vertexium.accumulo.accumulo;
 
 import java.io.IOException;
 import java.lang.management.CompilationMXBean;
@@ -48,7 +48,15 @@
 import org.apache.accumulo.core.client.TableNotFoundException;
 import org.apache.accumulo.core.client.TableOfflineException;
 import org.apache.accumulo.core.client.TimedOutException;
+import org.apache.accumulo.core.client.impl.AccumuloServerException;
+import org.apache.accumulo.core.client.impl.ClientContext;
+import org.apache.accumulo.core.client.impl.DurabilityImpl;
+import org.apache.accumulo.core.client.impl.Tables;
+import org.apache.accumulo.core.client.impl.TabletLocator;
 import org.apache.accumulo.core.client.impl.TabletLocator.TabletServerMutations;
+import org.apache.accumulo.core.client.impl.TimeoutTabletLocator;
+import org.apache.accumulo.core.client.impl.Translator;
+import org.apache.accumulo.core.client.impl.Translators;
 import org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode;
 import org.apache.accumulo.core.client.impl.thrift.ThriftSecurityException;
 import org.apache.accumulo.core.constraints.Violations;
@@ -79,6 +87,7 @@
 import org.slf4j.LoggerFactory;
 
 import com.google.common.base.Joiner;
+import org.vertexium.accumulo.CompletableMutation;
 
 /*
  * Differences from previous TabletServerBatchWriter
@@ -102,9 +111,9 @@
  *
  */
 
-public class TabletServerBatchWriter {
+public class VertexiumTabletServerBatchWriter {
 
-  private static final Logger log = LoggerFactory.getLogger(TabletServerBatchWriter.class);
+  private static final Logger log = LoggerFactory.getLogger(VertexiumTabletServerBatchWriter.class);
 
   // basic configuration
   private final ClientContext context;
@@ -124,7 +133,7 @@
   // latency timers
   private final Timer jtimer = new Timer("BatchWriterLatencyTimer", true);
   private final Map<String,TimeoutTracker> timeoutTrackers = Collections
-      .synchronizedMap(new HashMap<String,TabletServerBatchWriter.TimeoutTracker>());
+      .synchronizedMap(new HashMap<String,VertexiumTabletServerBatchWriter.TimeoutTracker>());
 
   // stats
   private long totalMemUsed = 0;
@@ -195,7 +204,7 @@
     }
   }
 
-  public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config) {
+  public VertexiumTabletServerBatchWriter(ClientContext context, BatchWriterConfig config) {
     this.context = context;
     this.maxMem = config.getMaxMemory();
     this.maxLatency = config.getMaxLatency(TimeUnit.MILLISECONDS) <= 0 ? Long.MAX_VALUE
@@ -212,9 +221,9 @@
         @Override
         public void run() {
           try {
-            synchronized (TabletServerBatchWriter.this) {
+            synchronized (VertexiumTabletServerBatchWriter.this) {
               if ((System.currentTimeMillis()
-                  - lastProcessingStartTime) > TabletServerBatchWriter.this.maxLatency)
+                  - lastProcessingStartTime) > VertexiumTabletServerBatchWriter.this.maxLatency)
                 startProcessing();
             }
           } catch (Throwable t) {
@@ -285,7 +294,7 @@
     // is important for the case where a mutation is passed from map to reduce
     // to batch writer... the map reduce code will keep passing the same mutation
     // object into the reduce method
-    m = new Mutation(m);
+    m = new CompletableMutation(m);
 
     totalMemUsed += m.estimatedMemoryUsed();
     mutations.addMutation(table, m);
@@ -849,8 +858,11 @@
           TabletServerMutations<Mutation> tsmuts = getMutationsToSend(location);
 
           while (tsmuts != null) {
-            send(tsmuts);
+            List<CompletableMutation> completedMutations = send(tsmuts);
             tsmuts = getMutationsToSend(location);
+            for (CompletableMutation completedMutation : completedMutations) {
+              completedMutation.complete();
+            }
           }
 
           return;
@@ -860,7 +872,7 @@
         }
       }
 
-      public void send(TabletServerMutations<Mutation> tsm)
+      public List<CompletableMutation> send(TabletServerMutations<Mutation> tsm)
           throws AccumuloServerException, AccumuloSecurityException {
 
         MutationSet failures = null;
@@ -915,6 +927,15 @@
             updateSendStats(count, st2 - st1);
             decrementMemUsed(successBytes);
 
+            List<CompletableMutation> completedMutations = new ArrayList<>();
+            for (Map.Entry<KeyExtent, List<Mutation>> mutationBatchEntry : mutationBatch.entrySet()) {
+              for (Mutation mutation : mutationBatchEntry.getValue()) {
+                if (!failures.hasMutation(mutation)) {
+                  completedMutations.add((CompletableMutation) mutation);
+                }
+              }
+            }
+            return completedMutations;
           } finally {
             span.stop();
           }
@@ -930,6 +951,7 @@
             getLocator(table).invalidateCache(context.getInstance(), location);
 
           failedMutations.add(location, tsm);
+          return Collections.emptyList();
         } finally {
           Thread.currentThread().setName(oldName);
         }
@@ -1104,5 +1126,15 @@
       return memoryUsed;
     }
 
+    public boolean hasMutation(Mutation mutation) {
+      for (Map.Entry<String, List<Mutation>> entry : mutations.entrySet()) {
+        for (Mutation m : entry.getValue()) {
+          if (m.equals(mutation)) {
+            return true;
+          }
+        }
+      }
+      return false;
+    }
   }
 }
